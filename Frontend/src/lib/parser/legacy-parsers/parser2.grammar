// This is an old grammar used for reference.

@precedence
{
    struct_initalization @left
    direct_member_access @left
    subscript @left
    call @left
    cast @left
    unary @right
    factor @left
    term @left
    comparison @left
    equality @left
    and @left
    xor @left
    or @left
    else @right
    ternary @right
    assign @right
}

@top Program
{
    (Stmt*)?
}

Stmt
{
    Func |
    Struct_decl ";" |
    Block_valid_stmt
}

Block_valid_stmt
{
    Decl_stmt ";" |
    If_stmt |
    Const_stmt ";" |
    Print_stmt ";" |
    Block |
    While_stmt |
    For_stmt |
    Return_stmt ";" |
    Break_stmt ";" |
    Continue_stmt ";" |
    Expr_stmt ";" |
    Type_stmt ";"
}

Struct_decl
{
    kw<"struct"> IDENTIFIER "{" (Field_member ("," Field_member)*)? "}"
}

Field_member
{
    IDENTIFIER ":" TYPE_LITERAL |
    IDENTIFIER ":" IDENTIFIER
}

Decl_stmt
{
    kw<"var"> IDENTIFIER ASSIGN_OP<"="> Expr |
    kw<"var"> IDENTIFIER ":" TYPE_LITERAL ASSIGN_OP<"="> Expr |
    kw<"var"> IDENTIFIER ":" IDENTIFIER ASSIGN_OP<"="> Expr
}

If_stmt
{
    kw<"if"> Expr Block !else kw<"then"> |
    kw<"if"> Expr Block kw<"else"> Block |
    kw<"if"> Expr Block kw<"else"> If_stmt
}

Const_stmt
{
    kw<"const"> IDENTIFIER ASSIGN_OP<"="> Expr |
    kw<"const"> IDENTIFIER ":" TYPE_LITERAL ASSIGN_OP<"="> Expr |
    kw<"const"> IDENTIFIER ":" IDENTIFIER ASSIGN_OP<"="> Expr
}

Print_stmt
{
    kw<"print"> Expr ("," Expr)*
}

Block
{
    "{" (Block_valid_stmt*)? "}"
}

Func
{
    kw<"fn"> IDENTIFIER "(" (Param ("," Param)*)? ")" Return_type? Block
}

While_stmt
{
    kw<"while"> Expr Block
}

For_stmt
{
    kw<"for"> Maybe_block_valid_stmt Expr? ";" Expr? Block
}

Maybe_block_valid_stmt
{
    ";" |
    Block_valid_stmt
}

Return_stmt
{
    kw<"return"> |
    kw<"return"> Expr
}

Break_stmt
{
   kw<"break">
}

Continue_stmt
{
   kw<"continue">
}

Expr_stmt
{
    Expr
}

Type_stmt
{
    kw<"type"> IDENTIFIER ASSIGN_OP<"="> TYPE_LITERAL |
    kw<"type"> IDENTIFIER ASSIGN_OP<"="> IDENTIFIER
}

Param
{
    IDENTIFIER ":" TYPE_LITERAL |
    IDENTIFIER ":" IDENTIFIER
}

Return_type
{
    "->" TYPE_LITERAL |
    "->" IDENTIFIER
}

Expr
{
    Assign_expr |
    Ternary_expr |
    Equality_expr |
    Comparison_expr |
    Term_expr |
    Factor_expr |
    And_expr |
    Xor_expr |
    Or_expr |
    Unary_expr |
    Type_cast |
    Call_expr |
    Subscript_expr |
    Direct_member_access |
    // Struct_initialization |
    Primary |
    Grouping
}

Assign_expr
{
    Expr !assign ASSIGN_OP<$[+\-*/%]?"="> Expr
}

Type_cast
{
    Expr kw<"as"> !cast IDENTIFIER |
    Expr kw<"as"> !cast TYPE_LITERAL
}

Ternary_expr
{
    Expr "?" Expr ":" !ternary Expr
}

Equality_expr
{
    Expr EQUALITY_OP<"="$[=!]> !equality Expr
}

Comparison_expr
{
    Expr COMPARISON_OP<$[<>]"="?> !comparison Expr
}

Term_expr
{
    Expr TERM_OP<$[+\-]> !term Expr
}

Factor_expr
{
    Expr FACTOR_OP<$[*%]> !factor Expr
}

Unary_expr
{
    PREFIX_UNARY_OP !unary Expr
}

And_expr
{
    Expr TYPE_LITERAL !and Expr
}

Xor_expr
{
    Expr LOGICAL_OP !xor Expr
}

Or_expr
{
    Expr LOGICAL_OP !or Expr
}

Call_expr
{
    Expr "(" (Expr ("," Expr)*)? !call ")"
}

// Struct_initialization
// {
//     IDENTIFIER "{" Maybe_struct_initialization_list "}"
// }

// Maybe_struct_initialization_list
// {
//     Struct_initialization_list? |
//     Struct_initialization_list ","
// }

// Struct_initialization_list
// {
//     IDENTIFIER "=" Expr |
//     Struct_initialization_list "," IDENTIFIER "=" Expr
// }

Subscript_expr {
    Expr "[" Expr !subscript "]"
}

Direct_member_access {
    Expr "." !subscript IDENTIFIER
}

Primary
{
    IDENTIFIER |
    INT_LITERAL |
    // FLOAT_LITERAL |
    BOOL_LITERAL |
    STR_LITERAL
}

Grouping
{
   "{" Expr "}" 
}

PREFIX_UNARY_OP
{
    PREFIX_UNARY_OP_SYMBOL<"-"> |
    kw<"not">
}

TYPE_LITERAL
{
    kw<"int"> |
    kw<"float"> |
    kw<"bool"> |
    kw<"str"> |
    kw<"void">
}

BOOL_LITERAL
{
    kw<"true"> |
    kw<"false">
}

LOGICAL_OP
{
    kw<"and"> |
    kw<"xor"> |
    kw<"or">
}



kw<term> { @specialize[@name={term}]<IDENTIFIER, term> }

@skip { SINGLELINE_COMMENT | MULTILINE_COMMENT | whitespace }

@skip {}
{
    STR_LITERAL { '"' (stringContentDouble)* ('"' | "\n") }
    MULTILINE_COMMENT { "/*" (blockCommentContent | blockCommentNewline)* blockCommentEnd }
}

@local tokens
{
    blockCommentEnd { "*/" }
    blockCommentNewline { "\n" }
    @else blockCommentContent
}

@tokens
{
    SINGLELINE_COMMENT { "//" ![\n]* }
    whitespace { $[ \t\n\r]+ }

    IDENTIFIER { $[a-zA-Z_]$[a-zA-Z0-9_]* }
    INT_LITERAL { $[0-9]+ }
    // EXP { $[Ee]$[-\+]?$[0-9]+ }
    // FLOAT_LITERAL { $[0-9]+"."$[0-9]+EXP? }

    stringContentDouble { ![\n"]+ }

    ASSIGN_OP<expr> { expr }
    EQUALITY_OP<expr> { expr }
    COMPARISON_OP<expr> { expr }
    FACTOR_OP<expr> { expr }
    TERM_OP<expr> { expr }
    PREFIX_UNARY_OP_SYMBOL<expr> { expr }

    "(" ")" "{" "}" "[" "]" ";" "." "," ":" "?" "->"
}

@external propSource taggedSyntax from "./syntax-highlighter2.js"